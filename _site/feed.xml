<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.7.3">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2018-03-18T22:31:57+08:00</updated><id>http://localhost:4000/</id><title type="html">Blog - Leach Chen</title><subtitle>Write an awesome description for your new site here. You can edit this line in _config.yml. It will appear in your document head meta (for Google search results) and in your feed.xml site description.
</subtitle><author><name>Leach Chen</name></author><entry><title type="html">3D相关摘记</title><link href="http://localhost:4000/3d/" rel="alternate" type="text/html" title="3D相关摘记" /><published>2018-03-15T11:18:00+08:00</published><updated>2018-03-15T11:18:00+08:00</updated><id>http://localhost:4000/3d</id><content type="html" xml:base="http://localhost:4000/3d/">&lt;h2 id=&quot;h5&quot;&gt;H5&lt;/h2&gt;
&lt;p&gt;WebGL  WebVR WebAR&lt;br /&gt;
&lt;a href=&quot;https://www.ddd.online/&quot; style=&quot;text-decoration: none;&quot; target=&quot;\_blank&quot; title=&quot;&quot;&gt;https://www.ddd.online/&lt;/a&gt;
&lt;a href=&quot;http://www.h5tu.com/&quot; style=&quot;text-decoration: none;&quot; target=&quot;\_blank&quot; title=&quot;&quot;&gt;http://www.h5tu.com/&lt;/a&gt;
&lt;a href=&quot;http://www.techbrood.com/&quot; style=&quot;text-decoration: none;&quot; target=&quot;\_blank&quot; title=&quot;&quot;&gt;http://www.techbrood.com/&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;unity3d&quot;&gt;Unity3d&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://unity3d.com/cn/&quot; style=&quot;text-decoration: none;&quot; target=&quot;\_blank&quot; title=&quot;&quot;&gt;https://unity3d.com/cn/&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;ue4&quot;&gt;UE4&lt;/h2&gt;
&lt;p&gt;虚幻引擎 4 (绝地求生)&lt;br /&gt;
&lt;a href=&quot;https://www.unrealengine.com/zh-CN/what-is-unreal-engine-4&quot; style=&quot;text-decoration: none;&quot; target=&quot;\_blank&quot; title=&quot;&quot;&gt;https://www.unrealengine.com/zh-CN/what-is-unreal-engine-4&lt;/a&gt;
&lt;a href=&quot;http://blog.csdn.net/dj0379/article/details/51919946&quot; style=&quot;text-decoration: none;&quot; target=&quot;\_blank&quot; title=&quot;&quot;&gt;http://blog.csdn.net/dj0379/article/details/51919946&lt;/a&gt;
&lt;a href=&quot;https://www.cnblogs.com/majianchao/p/6270797.html&quot; style=&quot;text-decoration: none;&quot; target=&quot;\_blank&quot; title=&quot;&quot;&gt;https://www.cnblogs.com/majianchao/p/6270797.html&lt;/a&gt;&lt;/p&gt;</content><author><name>Leach Chen</name></author><category term="3D" /><summary type="html">H5 WebGL WebVR WebAR https://www.ddd.online/ http://www.h5tu.com/ http://www.techbrood.com/</summary></entry><entry><title type="html">网址摘记</title><link href="http://localhost:4000/website/" rel="alternate" type="text/html" title="网址摘记" /><published>2018-03-13T14:00:00+08:00</published><updated>2018-03-13T14:00:00+08:00</updated><id>http://localhost:4000/website</id><content type="html" xml:base="http://localhost:4000/website/">&lt;p&gt;网址摘记,持续更新………&lt;/p&gt;

&lt;h2 id=&quot;google相关&quot;&gt;Google相关&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Google 开发者登录网址&lt;/strong&gt;&lt;br /&gt;
&lt;a href=&quot;https://play.google.com/apps/publish/signup/&quot; style=&quot;text-decoration: none;&quot; target=&quot;\_blank&quot; title=&quot;&quot;&gt;https://play.google.com/apps/publish/signup/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Google 所有产品文档网址&lt;/strong&gt;&lt;br /&gt;
&lt;a href=&quot;https://developers.google.com/products/&quot; style=&quot;text-decoration: none;&quot; target=&quot;\_blank&quot; title=&quot;&quot;&gt;https://developers.google.com/products/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Google Android开发者网址&lt;/strong&gt;&lt;br /&gt;
&lt;a href=&quot;https://developer.android.com/about/versions/oreo/index.html?hl=zh-CN&quot; style=&quot;text-decoration: none;&quot; target=&quot;\_blank&quot; title=&quot;&quot;&gt;https://developer.android.com/about/versions/oreo/index.html?hl=zh-CN&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Google Maps 文档网址&lt;/strong&gt;&lt;br /&gt;
&lt;a href=&quot;https://developers.google.com/maps/&quot; style=&quot;text-decoration: none;&quot; target=&quot;\_blank&quot; title=&quot;&quot;&gt;https://developers.google.com/maps/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Google Analytics登录网址&lt;/strong&gt;&lt;br /&gt;
&lt;a href=&quot;https://analytics.google.com/analytics&quot; style=&quot;text-decoration: none;&quot; target=&quot;\_blank&quot; title=&quot;&quot;&gt;https://analytics.google.com/analytics&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Google Analytics 文档网址&lt;/strong&gt;&lt;br /&gt;
&lt;a href=&quot;https://support.google.com/analytics#topic=3544906&quot; style=&quot;text-decoration: none;&quot; target=&quot;\_blank&quot; title=&quot;&quot;&gt;https://support.google.com/analytics#topic=3544906&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;云服务&quot;&gt;云服务&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;华为云服务&lt;/strong&gt;&lt;br /&gt;
&lt;a href=&quot;https://www.huaweicloud.com/product/&quot; style=&quot;text-decoration: none;&quot; target=&quot;\_blank&quot; title=&quot;&quot;&gt;https://www.huaweicloud.com/product/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;阿里云服务&lt;/strong&gt;&lt;br /&gt;
&lt;a href=&quot;https://www.aliyun.com/?utm_medium=text&amp;amp;utm_source=bdbrand&amp;amp;utm_campaign=bdbrand&amp;amp;utm_content=se_32492&quot; style=&quot;text-decoration: none;&quot; target=&quot;\_blank&quot; title=&quot;&quot;&gt;https://www.aliyun.com/?utm_medium=text&amp;amp;utm_source=bdbrand&amp;amp;utm_campaign=bdbrand&amp;amp;utm_content=se_32492&lt;/a&gt;&lt;/p&gt;</content><author><name>Leach Chen</name></author><category term="Other" /><summary type="html">网址摘记,持续更新………</summary></entry><entry><title type="html">Android优秀Blog网址</title><link href="http://localhost:4000/blogaddress/" rel="alternate" type="text/html" title="Android优秀Blog网址" /><published>2018-03-13T09:00:00+08:00</published><updated>2018-03-13T09:00:00+08:00</updated><id>http://localhost:4000/blogaddress</id><content type="html" xml:base="http://localhost:4000/blogaddress/">&lt;p&gt;优秀Blog网址，持续更新……….&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;郭林&lt;/strong&gt;&lt;br /&gt;
&lt;a href=&quot;http://blog.csdn.net/guolin_blog?viewmode=list&quot; style=&quot;text-decoration: none;&quot; target=&quot;\_blank&quot; title=&quot;&quot;&gt;http://blog.csdn.net/guolin_blog?viewmode=list&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;鸿洋&lt;/strong&gt;&lt;br /&gt;
&lt;a href=&quot;http://blog.csdn.net/lmj623565791/&quot; style=&quot;text-decoration: none;&quot; target=&quot;\_blank&quot; title=&quot;&quot;&gt;http://blog.csdn.net/lmj623565791/&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;http://mp.sohu.com/profile?xpt=aG9uZ3lhbmdhbmRyb2lkQHNvaHUuY29t&amp;amp;_f=index_pagemp_1&quot; style=&quot;text-decoration: none;&quot; target=&quot;\_blank&quot; title=&quot;&quot;&gt;http://mp.sohu.com/profile?xpt=aG9uZ3lhbmdhbmRyb2lkQHNvaHUuY29t&amp;amp;_f=index_pagemp_1&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;尼古拉斯_赵四&lt;/strong&gt;&lt;br /&gt;
&lt;a href=&quot;http://blog.csdn.net/jiangwei0910410003/&quot; style=&quot;text-decoration: none;&quot; target=&quot;\_blank&quot; title=&quot;&quot;&gt;http://blog.csdn.net/jiangwei0910410003/&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;http://www.wjdiankong.cn/&quot; style=&quot;text-decoration: none;&quot; target=&quot;\_blank&quot; title=&quot;&quot;&gt;http://www.wjdiankong.cn/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;任玉刚&lt;/strong&gt;&lt;br /&gt;
&lt;a href=&quot;http://blog.csdn.net/singwhatiwanna?viewmode=list&quot; style=&quot;text-decoration: none;&quot; target=&quot;\_blank&quot; title=&quot;&quot;&gt;http://blog.csdn.net/singwhatiwanna?viewmode=list&lt;/a&gt;&lt;/p&gt;</content><author><name>Leach Chen</name></author><category term="Android" /><category term="Blog" /><summary type="html">优秀Blog网址，持续更新……….</summary></entry><entry><title type="html">Android JNI—函数用法</title><link href="http://localhost:4000/android-jni-method/" rel="alternate" type="text/html" title="Android JNI—函数用法" /><published>2018-03-12T15:16:00+08:00</published><updated>2018-03-12T15:16:00+08:00</updated><id>http://localhost:4000/android-jni-method</id><content type="html" xml:base="http://localhost:4000/android-jni-method/">&lt;p&gt;记录用到的JNI函数用法，持续更新…&lt;/p&gt;</content><author><name>Leach Chen</name></author><category term="Android" /><category term="JNI" /><summary type="html">记录用到的JNI函数用法，持续更新…</summary></entry><entry><title type="html">Markdown语法摘记</title><link href="http://localhost:4000/markdown/" rel="alternate" type="text/html" title="Markdown语法摘记" /><published>2018-03-12T11:00:00+08:00</published><updated>2018-03-12T11:00:00+08:00</updated><id>http://localhost:4000/markdown</id><content type="html" xml:base="http://localhost:4000/markdown/">&lt;p&gt;主要记录在用markdown写博客时用到的语法，持续更新…&lt;/p&gt;

&lt;h3 id=&quot;1-引用代码不被解析标记为代码段&quot;&gt;&lt;strong&gt;1. &lt;a href=&quot;https://www.zhihu.com/question/30425128&quot; style=&quot;text-decoration: none;&quot; target=&quot;\_blank&quot; title=&quot;点击前往&quot;&gt;引用代码不被解析,标记为代码段&lt;/a&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;键盘左上角那个不常用的`，按三下加语言，即```html，写完代码再 ```裹起来，就可以实现代码着色。&lt;/p&gt;

&lt;h3 id=&quot;2-标题大小&quot;&gt;&lt;strong&gt;2. 标题大小&lt;/strong&gt;&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# 标题1 #             相当于&amp;lt;h1&amp;gt;标题1&amp;lt;/h1&amp;gt;
## 标题2 ##           相当于&amp;lt;h2&amp;gt;标题2&amp;lt;/h2&amp;gt;
### 标题3 ###         相当于&amp;lt;h3&amp;gt;标题3&amp;lt;/h3&amp;gt;
#### 标题4 ####       相当于&amp;lt;h4&amp;gt;标题4&amp;lt;/h4&amp;gt;
##### 标题5 #####     相当于&amp;lt;h5&amp;gt;标题5&amp;lt;/h5&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h1 id=&quot;标题1&quot;&gt;标题1&lt;/h1&gt;
&lt;h2 id=&quot;标题2&quot;&gt;标题2&lt;/h2&gt;
&lt;h3 id=&quot;标题3&quot;&gt;标题3&lt;/h3&gt;
&lt;h4 id=&quot;标题4&quot;&gt;标题4&lt;/h4&gt;
&lt;h5 id=&quot;标题5&quot;&gt;标题5&lt;/h5&gt;

&lt;h3 id=&quot;3-链接&quot;&gt;&lt;strong&gt;3. 链接&lt;/strong&gt;&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[测试链接](https://leach-chen.github.io/ &quot;点击前往&quot;)     相当于
&amp;lt;a href=&quot;https://leach-chen.github.io/&quot; style=&quot;text-decoration: none;&quot; target=&quot;_blank&quot;  title=&quot;点击前往&quot;&amp;gt;测试链接&amp;lt;/a&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;a href=&quot;https://leach-chen.github.io/&quot; title=&quot;点击前往&quot;&gt;测试链接&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;4-图片&quot;&gt;&lt;strong&gt;4. 图片&lt;/strong&gt;&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;![](/assets/img/leach-face.jpg)        相当于
&amp;lt;img src=&quot;/assets/img/leach-face.jpg&quot; height=&quot;100%&quot;/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;/assets/img/leach-face.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;5-加粗&quot;&gt;&lt;strong&gt;5. 加粗&lt;/strong&gt;&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;**加粗**
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;加粗&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;6-有序编号&quot;&gt;&lt;strong&gt;6. 有序编号&lt;/strong&gt;&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1. 编号1
1. 编号2
注意：点后面有个空格
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;编号1&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;编号2&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;7-点编号&quot;&gt;&lt;strong&gt;7. 点编号&lt;/strong&gt;&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- 编号1
- 编号2
注意：-后面有个空格
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;编号1&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;编号2&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;8-块标记&quot;&gt;&lt;strong&gt;8. 块标记&lt;/strong&gt;&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;测试标记
&amp;gt;
&amp;gt;测试标记
&amp;gt;
&amp;gt;测试标记
&amp;gt;
&amp;gt;测试标记
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;blockquote&gt;
  &lt;p&gt;测试标记&lt;/p&gt;

  &lt;p&gt;测试标记&lt;/p&gt;

  &lt;p&gt;测试标记&lt;/p&gt;

  &lt;p&gt;测试标记&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;9-分隔线&quot;&gt;&lt;strong&gt;9. 分隔线&lt;/strong&gt;&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; ---
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;10-创建表格&quot;&gt;&lt;strong&gt;10. &lt;a href=&quot;http://blog.csdn.net/tuxingchen6/article/details/55222951&quot; style=&quot;text-decoration: none;&quot; target=&quot;\_blank&quot; title=&quot;点击前往&quot;&gt;创建表格&lt;/a&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Name | Academy | score
- | :-: | -:      //-靠左对齐，:-:居中对齐，-:靠右对齐
Harry Potter | Gryffindor| 90
Hermione Granger | Gryffindor | 100
Draco Malfoy | Slytherin | 90
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Name&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;Academy&lt;/th&gt;
      &lt;th style=&quot;text-align: right&quot;&gt;score&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;Harry Potter&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Gryffindor&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;90&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Hermione Granger&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Gryffindor&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;100&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Draco Malfoy&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Slytherin&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;90&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;| Name | Academy | score |
| - | :-: | -: |
| Harry Potter | Gryffindor| 90 |
| Hermione Granger | Gryffindor | 100 |
| Draco Malfoy | Slytherin | 90 |
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Name&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;Academy&lt;/th&gt;
      &lt;th style=&quot;text-align: right&quot;&gt;score&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;Harry Potter&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Gryffindor&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;90&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Hermione Granger&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Gryffindor&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;100&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Draco Malfoy&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Slytherin&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;90&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;a href=&quot;http://ask.csdn.net/questions/259502&quot; style=&quot;text-decoration: none;&quot; target=&quot;\_blank&quot; title=&quot;点击前往&quot;&gt;创建的表格没有横线？&lt;/a&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;在css里面添加如下代码:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    table{
        border-left:1px solid #000000;border-top:1px solid #000000;
        width: 100%;
        word-wrap:break-word; word-break:break-all;
      }
      table th{
      text-align:center;
      }
      table th,td{
        border-right:1px solid #000000;border-bottom:1px solid #000000;
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name>Leach Chen</name></author><category term="Markdown" /><summary type="html">主要记录在用markdown写博客时用到的语法，持续更新…</summary></entry><entry><title type="html">Android JNI—数据类型及对JNI理解</title><link href="http://localhost:4000/android-jni-datatype/" rel="alternate" type="text/html" title="Android JNI—数据类型及对JNI理解" /><published>2018-03-07T17:22:00+08:00</published><updated>2018-03-07T17:22:00+08:00</updated><id>http://localhost:4000/android-jni-datatype</id><content type="html" xml:base="http://localhost:4000/android-jni-datatype/">&lt;p&gt;本节主要介绍下JNI的&lt;strong&gt;函数命名及参数说明，数据类型对应关系，描述符及对JNI的理解&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;JNI Java Native Interface（Java本地接口）。做JAVA或者Android的朋友可能会接触到JNI的开发，特别是涉及到音视频、与硬件设备有交互的时候、封装一些复杂逻辑或者算法、上层处理性能跟不上等情况下。JNI开发偏底层开发，编译出来的库的后缀为.so，它也更安全更难破解。JNI开发需要懂C/C++，可基于Android Studio、Eclipse，VS等开发工具进行开发，一般由C/C++开发者进行开发并且支持Android，IOS平台。若你又精通Android上层开发，又精通JNI底层开发,那你的级别又将上升一个档次。&lt;/p&gt;

&lt;h2 id=&quot;1-函数命名及参数说明&quot;&gt;&lt;strong&gt;1. 函数命名及参数说明&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;第一篇文章提到过静态注册和动态注册，若是静态注册，则命名需要为固定格式，动态注册则不需要，这里以静态注册方式来说：&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;JNIEXPORT jstring JNICALL Java_com_leachchen_testjni_MainActivity_testMethod(JNIEnv *env, jobject instance, jstring name_)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;a函数参数&quot;&gt;&lt;strong&gt;a.函数参数&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;Java是函数的前缀，com_leachchen_testjni_MainActivity是函数所在类路径，testMethod是方法名；&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;第一个参数：JNIEnv* 是定义任意native函数的第一个参数（包括调用JNI的RegisterNatives函数注册的函数），指向JVM函数表的指针，函数表中的每一个入口指向一个JNI函数，每个函数用于访问JVM中特定的数据结构。&lt;/p&gt;

&lt;p&gt;第二个参数：调用java中native方法的实例或Class对象，如果这个native方法是实例方法，则该参数是jobject，如果是静态方法，则是jclass&lt;/p&gt;

&lt;p&gt;第三个参数：Java对应JNI中的数据类型，Java中String类型对应JNI的jstring类型。&lt;/p&gt;

&lt;h3 id=&quot;b函数返回值&quot;&gt;&lt;strong&gt;b.函数返回值&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;JNIEXPORT和JNICALL宏中间的jstring，表示函数的返回值类型，对应Java的String类型&lt;/p&gt;

&lt;h2 id=&quot;2-数据类型对应关系&quot;&gt;&lt;strong&gt;2. &lt;a href=&quot;http://blog.csdn.net/xyang81/article/details/42047899&quot; style=&quot;text-decoration: none;&quot; target=&quot;\_blank&quot; title=&quot;点击前往&quot;&gt;数据类型对应关系:&lt;/a&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;在调用Java native方法将实参传递给C/C++函数的时候，会自动将java形参的数据类型自动转换成C/C++相应的数据类型，所以我们在写JNI程序的时候，必须要明白它们之间数据类型的对应关系。&lt;/p&gt;

&lt;h3 id=&quot;a基本数据类型&quot;&gt;&lt;strong&gt;a.基本数据类型&lt;/strong&gt;&lt;/h3&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;Java Type&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;Native type&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;Description&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;boolean&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;jboolean&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;unsigned 8 bits&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;byte&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;jbyte&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;signed 8 bits&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;char&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;jchar&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;unsigned 16 bits&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;short&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;jshort&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;signed 16 bits&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;int&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;jint&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;signed 32 bits&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;long&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;jlong&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;signed 64 bits&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;float&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;jfloat&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;32 bits&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;double&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;jdouble&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;64 bits&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;b引用类型&quot;&gt;&lt;strong&gt;b.引用类型&lt;/strong&gt;&lt;/h3&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;Java Type&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;Native type&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;Description&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;all object&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;jobject&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;java.lang.Class instances&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;jstring&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;arrays&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;jarray&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Object[]&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;jobjectArray&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;boolean[]&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;jbooleanArray&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;byte[]&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;jbyteArray&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;char[]&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;jcharArray&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;int[]&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;jintArray&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;long[]&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;jlongArray&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;float[]&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;jfloatAyyay&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;double[]&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;jdoubleArray&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;java.lang.Throwable Objects&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;jthrowable&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;3-描述符&quot;&gt;&lt;strong&gt;3. &lt;a href=&quot;http://blog.csdn.net/likuan0214/article/details/52584785&quot; style=&quot;text-decoration: none;&quot; target=&quot;\_blank&quot; title=&quot;点击前往&quot;&gt;描述符&lt;/a&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;h3 id=&quot;a类描述符&quot;&gt;&lt;strong&gt;a.类描述符&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;类描述符用来表示一个类或者接口的名字。把类或者接口在java中所定义的完整名称中的”.”替换成”/”就是类描述符。&lt;br /&gt;
比如java.lang.String的类描述符为：&lt;strong&gt;java/lang/string&lt;/strong&gt;&lt;br /&gt;
数组类的描述符：在”[“后面跟着数组元素的类型的字段描述符,如：&lt;br /&gt;
&lt;strong&gt;“int[]”&lt;/strong&gt;的类描述符为：&lt;strong&gt;“[I”&lt;/strong&gt;&lt;br /&gt;
&lt;strong&gt;“double[][][]”&lt;/strong&gt;的类描述符为：&lt;strong&gt;”[[[D”&lt;/strong&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;b字段描述符&quot;&gt;&lt;strong&gt;b.字段描述符:&lt;/strong&gt;&lt;/h4&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;Java Type&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;Native type&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;Description&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;boolean&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Z&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;byte&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;B&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;char&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;C&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;short&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;S&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;int&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;I&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;long&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;J&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;float&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;F&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;double&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;D&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;引用类型的字段描述符的第一个字符是”L”，接着写类描述符，最后以”;”结尾。&lt;br /&gt;
数组类型的字段描述符的定义规则和数组类描述符一致。 &lt;br /&gt;
下面的例子是引用类型的字段描述符和他们相对应的java类型：&lt;br /&gt;&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;Java Type&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;Native type&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;Description&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;String&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;“Ljava/lang/String;”&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;int[]&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;“[I”&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Object[]&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;“[Ljava/lang/Object;”&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;c方法描述符&quot;&gt;&lt;strong&gt;c.方法描述符&lt;/strong&gt;&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;方法描述符首先在”()”中写所有的参数类型的字段描述符，然后在”()”后面接着写返回类型的字段描述符。&lt;/li&gt;
  &lt;li&gt;并且在参数类型的字段描述符之间不能有空格或者其他分隔符。&lt;/li&gt;
  &lt;li&gt;“V”用来表示没有返回类型。&lt;/li&gt;
  &lt;li&gt;构造函数使用”V”做为返回类型，并且使用”&amp;lt; init&amp;gt;”做为函数名。&lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;Java Type&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;Native type&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;Description&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;String f();&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;”()Ljava/lang/String;”&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;long f(int i, Class c);&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;“(ILjava/lang/Class;)J”&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;String(byte[] bytes);&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;”([B)V”&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;4-理解&quot;&gt;&lt;strong&gt;4. 理解&lt;/strong&gt;&lt;/h2&gt;
&lt;h3 id=&quot;a函数参数-jnienv-env-jobject-instance-理解&quot;&gt;&lt;strong&gt;a.函数参数 (JNIEnv *env, jobject instance )理解&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;基本类型很容易理解，就是对C/C++中的基本类型用typedef重新定义了一个新的名字，在JNI中可以直接访问。
JNI把Java中的所有对象当作一个C指针传递到本地方法中，这个指针指向JVM中的内部数据结构，而内部的数据结构在内存中的存储方式是不可见的。只能从JNIEnv指针指向的函数表中选择合适的JNI函数来操作JVM中的数据结构。如访问java.lang.String对应的JNI类型jstring时，没有像访问基本数据类型一样直接使用，因为它在Java是一个引用类型，所以在本地代码中只能通过GetStringUTFChars这样的JNI函数来访问字符串的内容。如：&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;testMethod(JNIEnv *env, jobject instance, jstring name_)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Java内部的数据结构（除基本数据类型外）对JNI来说是不可见的，如上面函数中，Java传递过来了一个字符串类型的name_变量，name_变量在JVM中的数据结构对JNI来说是不可见的，那JNI如何访问到这个变量呢？*env指针指向的函数表中的GetStringUTFChars变能访问到JVM中的数据结构，调用GetStringUTFChars可以获取到该字符串的值，然后再赋值给JNI中的变量，这样便完成了JAVA-》JNI的一个传值过程。若JNI想返回一个字符串给JAVA，那么需要调用NewStringUTF，将JNI中的字符串，包装成符合JAVA字符串数据结构，的字符串，然后返回JVM便能够识别到了。&lt;/p&gt;

&lt;p&gt;jobject instance&lt;br /&gt;
如果native方法不是static的话，这个obj就代表这个native方法的类实例
如果native方法是static的话，这个obj就代表这个native方法的类的class对象实例(static方法不需要类实例的，所以就代表这个类的class对象)&lt;/p&gt;

&lt;h3 id=&quot;b调用getstringutfchars后需要调用releasestringutfchars&quot;&gt;&lt;strong&gt;b.调用GetStringUTFChars后需要调用ReleaseStringUTFChars&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;在调用GetStringUTFChars函数从JVM内部获取一个字符串之后，JVM内部会分配一块新的内存，用于存储源字符串的拷贝，以便本地代码访问和修改。即然有内存分配，用完之后马上释放是一个编程的好习惯。通过调用ReleaseStringUTFChars函数通知JVM这块内存已经不使用了，你可以清除了。注意：这两个函数是配对使用的，用了GetXXX就必须调用ReleaseXXX，而且这两个函数的命名也有规律，除了前面的Get和Release之外，后面的都一样。&lt;/p&gt;</content><author><name>Leach Chen</name></author><category term="Android" /><category term="JNI" /><summary type="html">本节主要介绍下JNI的函数命名及参数说明，数据类型对应关系，描述符及对JNI的理解。</summary></entry><entry><title type="html">Android JNI—CmakeLists详解</title><link href="http://localhost:4000/android-jni-cmake/" rel="alternate" type="text/html" title="Android JNI—CmakeLists详解" /><published>2018-03-07T17:21:00+08:00</published><updated>2018-03-07T17:21:00+08:00</updated><id>http://localhost:4000/android-jni-cmake</id><content type="html" xml:base="http://localhost:4000/android-jni-cmake/">&lt;p&gt;敬请期待…………&lt;/p&gt;</content><author><name>Leach Chen</name></author><category term="Android" /><category term="JNI" /><summary type="html">敬请期待…………</summary></entry><entry><title type="html">Android JNI—Android.mk详解</title><link href="http://localhost:4000/android-jni-mk/" rel="alternate" type="text/html" title="Android JNI—Android.mk详解" /><published>2018-03-07T17:20:00+08:00</published><updated>2018-03-07T17:20:00+08:00</updated><id>http://localhost:4000/android-jni-mk</id><content type="html" xml:base="http://localhost:4000/android-jni-mk/">&lt;p&gt;看一个简单的Android.mk的例子：&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;LOCAL_PATH := $(call my-dir)&lt;br /&gt;&lt;/p&gt;

  &lt;p&gt;include $(CLEAR_VARS)&lt;br /&gt;&lt;/p&gt;

  &lt;p&gt;LOCAL_MODULE    := hello-jni&lt;br /&gt;
LOCAL_SRC_FILES := hello-jni.c&lt;br /&gt;&lt;/p&gt;

  &lt;p&gt;include $(BUILD_SHARED_LIBRARY)&lt;br /&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;例子说明&quot;&gt;&lt;strong&gt;例子说明&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;LOCAL_PATH:=$(call my-dir)&lt;/strong&gt;&lt;br /&gt;
Android.mk文件首先必须要指定LOCAL_PATH变量，用于查找源文件。一般情况下Android.mk和需要编译的源文件在同一目录下。上面的语句的意思是将LOCAL_PATH变量定义成本文件所在目录路径。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;include $(CLEAR_VARS)&lt;/strong&gt;&lt;br /&gt;
Android.mk中可以定义多个编译模块，每个编译模块都是以include $(CLEAR_VARS)开始，以include $(BUILD_XXX)结束。&lt;br /&gt;
CLEAR_VARS由编译系统提供，指定让GNU MAKEFILE为你清除除LOCAL_PATH以外的所有LOCAL_XXX变量，清除它们可以避免冲突，每一个原生组件被称为一个模块。如LOCAL_MODULE，LOCAL_SRC_FILES，LOCAL_SHARED_LIBRARIES，LOCAL_STATIC_LIBRARIES等。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;LOCAL_MODULE ：= hello-jni&lt;/strong&gt;&lt;br /&gt;
LOCAL_MODULE模块必须定义，以表示Android.mk中的每一个模块。名字必须唯一且不包含空格。Build System会自动添加适当的前缀和后缀。例如，foo，要产生动态库，则生成libfoo.so. 但请注意：如果模块名被定为：libfoo.则生成libfoo.so. 不再加前缀。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;LOCAL_SRC_FILES：= hello-jni.c&lt;/strong&gt;&lt;br /&gt;
LOCAL_SRC_FILES变量必须包含将要打包如模块的C/C++ 源码。不必列出头文件，build System 会自动帮我们找出依赖文件。缺省的C++源码的扩展名为.cpp. 也可以修改，通过LOCAL_CPP_EXTENSION。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;include $(BUILD_XXX)&lt;/strong&gt;&lt;br /&gt;
BUILD_XXX是Build System提供的一个变量，指向一个GNU Makefile Script。它负责收集自从上次调用 include $(CLEAR_VARS)后的所有LOCAL_XXX信息。并决定编译为什么。&lt;br /&gt;
BUILD_SHARED_LIBRARY：将你列出的Source编译成一个动态库。注意，在包含此文件前，至少应该包含：LOCAL_MODULE and LOCAL_SRC_FILES 。&lt;br /&gt;
BUILD_STATIC_LIBRARY：将你列出的Source编译成一个静态库。静态库不能够加入到Project 或者APK中。但它可以用来生成动态库。。&lt;br /&gt;
BUILD_EXECUTABLE：编译为Native C可执行程序&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;变量说明&quot;&gt;&lt;strong&gt;变量说明&lt;/strong&gt;&lt;/h2&gt;

&lt;hr /&gt;
&lt;p&gt;NDK Build System变量&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;CLEAR_VARS&lt;/strong&gt;&lt;br /&gt;
指向一个编译脚本。必须在新模块前包含之。&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;include $(CLEAR_VARS)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;BUILD_SHARED_LIBRARY&lt;/strong&gt;&lt;br /&gt;
指向一个编译脚本，它收集自从上次调用 include $(CLEAR_VARS)  后的所有LOCAL_XXX信息。
并决定如何将你列出的Source编译成一个动态库。 注意，在包含此文件前，至少应该包含：LOCAL_MODULE and LOCAL_SRC_FILES 例如：&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;include $(BUILD_SHARED_LIBRARY)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;BUILD_STATIC_LIBRARY&lt;/strong&gt;&lt;br /&gt;
与前面类似，它也指向一个编译脚本，
收集自从上次调用 include $(CLEAR_VARS)  后的所有LOCAL_XXX信息。
并决定如何将你列出的Source编译成一个静态库。 静态库不能够加入到Project 或者APK中。但它可以用来生成动态库。
LOCAL_STATIC_LIBRARIES and LOCAL_WHOLE_STATIC_LIBRARIES将描述之。&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;include $(BUILD_STATIC_LIBRARY)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;BUILD_EXECUTABLE&lt;/strong&gt;&lt;br /&gt;
与前面类似，它也指向一个编译脚本，收集自从上次调用 include $(CLEAR_VARS)  后的所有LOCAL_XXX信息。
并决定如何将你列出的Source编译成一个可执行Native程序。&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;include $(BUILD_EXECUTABLE)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;PREBUILT_SHARED_LIBRARY&lt;/strong&gt;&lt;br /&gt;
把这个共享库声明为 “一个” 独立的模块。
指向一个build 脚本，用来指定一个预先编译好多动态库。 与BUILD_SHARED_LIBRARY and BUILD_STATIC_LIBRARY不同，
此时模块的LOCAL_SRC_FILES应该被指定为一个预先编译好的动态库，而非source file.  LOCAL_PATH := $(call my-dir)&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;include $(CLEAR_VARS)&lt;br /&gt;
&lt;br /&gt;
LOCAL_MODULE := foo-prebuilt     # 模块名&lt;br /&gt;
LOCAL_SRC_FILES := libfoo.so     # 模块的文件路径（相对于 LOCAL_PATH）&lt;br /&gt;
&lt;br /&gt;
include $(PREBUILT_SHARED_LIBRARY) # 注意这里不是 BUILD_SHARED_LIBRARY&lt;br /&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这个共享库将被拷贝到 $PROJECT/obj/local 和 $PROJECT/libs/&lt;abi&gt; (stripped)  主要是用在将已经编译好的第三方库
使用在本Android Project中。为什么不直接将其COPY到libs/armabi目录呢？因为这样做缺陷很多。下一节再详细说明。&lt;/abi&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;PREBUILT_STATIC_LIBRARY&lt;/strong&gt;&lt;br /&gt;
预先编译的静态库。同上。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;TARGET_ARCH&lt;/strong&gt;&lt;br /&gt;
目标ＣＰＵ架构名。如果为“arm” 则声称ARM兼容的指令。与CPU架构版本无关。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;TARGET_PLATFORM&lt;/strong&gt;&lt;br /&gt;
目标平台的名字。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;TARGET_ARCH_ABI&lt;/strong&gt;&lt;br /&gt;
Name of the target CPU+ABI&lt;br /&gt;
armeabi For ARMv5TE  armeabi-v7a&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;TARGET_ABI&lt;/strong&gt;&lt;br /&gt;
目标平台和 ABI 的组合&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;NDK提供的功能宏&lt;br /&gt;
GNU　Make 提供的功能宏，只有通过类似： $(call function)   的方式来得到其值，它将返回文本化的信息。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;my-dir: $(call my-dir)&lt;/strong&gt;&lt;br /&gt;
返回最近一次include的Makefile的路径。通常返回Android.mk所在的路径。它用来作为Android.mk的开头来定义LOCAL_PATH.&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;LOCAL_PATH := $(call my-dir)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;请注意：返回的是最近一次include的Makefile的路径。所以在Include其它Makefile后，再调用$(call my-dir)会返回其它Android.mk 所在路径。例如：&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;LOCAL_PATH := $(call my-dir)   … declare one module &lt;br /&gt;
include $(LOCAL_PATH)/foo/Android.mk&lt;br /&gt;
LOCAL_PATH := $(call my-dir)   … declare another module&lt;br /&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;则第二次返回的LOCAL_PATH　为：$PATH/foo。 而非$PATH.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;all-subdir-makefiles&lt;/strong&gt;&lt;br /&gt;
返回一个列表，包含’my-dir’中所有子目录中的Android.mk。如结构如下：&lt;br /&gt;
sources/foo/Android.mk   sources/foo/lib1/Android.mk   sources/foo/lib2/Android.mk&lt;br /&gt;
在If sources/foo/Android.mk 中， include $(call all-subdir-makefiles)  那则自动include 了sources/foo/lib1/Android.mk and sources/foo/lib2/Android.mk。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;this-makefile&lt;/strong&gt;&lt;br /&gt;
当前Makefile的路径。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;parent-makefile&lt;/strong&gt;&lt;br /&gt;
返回include tree中父Makefile 路径。 也就是include 当前Makefile的Makefile Path。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;import-module&lt;/strong&gt;&lt;br /&gt;
允许寻找并inport其它modules到本Android.mk中来。 它会从NDK_MODULE_PATH寻找指定的模块名。&lt;br /&gt;
$(call import-module,&lt;name&gt;)&lt;/name&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;模块描述变量&lt;br /&gt;
此类变量用来给Build System描述模块信息。在’include $(CLEAR_VARS)’ 和 ‘include $(BUILD_XXXXX)’之间。必须定义此类变量。
include $(CLEAR_VARS) script用来清空这些变量。 &lt;br /&gt;
include $(BUILD_XXXXX)收集和使用这些变量。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;LOCAL_PATH&lt;/strong&gt;&lt;br /&gt;
这个值用来给定当前目录。必须在Android.mk的开是位置定义之。
例如：  LOCAL_PATH := $(call my-dir)   LOCAL_PATH不会被include $(CLEAR_VARS) 清理。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;LOCAL_MODULE&lt;/strong&gt;&lt;br /&gt;
modules名。在include $(BUILD_XXXXX)之前，必须定义这个变量。此变量必须唯一且不能有空格。 &lt;br /&gt;
通常，由此变量名决定最终生成的目标文件名。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;LOCAL_MODULE_FILENAME&lt;/strong&gt;&lt;br /&gt;
可选。用来override LOCAL_MODULE. 即允许用户重新定义最终生成的目标文件名。  &lt;br /&gt;
LOCAL_MODULE := foo-version-1  LOCAL_MODULE_FILENAME := libfoo&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;LOCAL_SRC_FILES&lt;/strong&gt;&lt;br /&gt;
为Build Modules而提供的Source 文件列表。不需要列出依赖文件。 注意：文件相对于LOCAL_PATH存放，
且可以提供相对路径。 例如：&lt;br /&gt;
LOCAL_SRC_FILES := foo.c               \ toto/bar.c&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;LOCAL_CPP_EXTENSION&lt;/strong&gt;&lt;br /&gt;
指出C++ 扩展名。(可选)&lt;br /&gt;
LOCAL_CPP_EXTENSION := .cxx 从NDK R7后，可以写多个：&lt;br /&gt;
LOCAL_CPP_EXTENSION := .cxx .cpp .cc&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;LOCAL_CPP_FEATURES&lt;/strong&gt;&lt;br /&gt;
可选。用来指定C++ features。&lt;br /&gt;
LOCAL_CPP_FEATURES := rtti&lt;br /&gt;
LOCAL_CPP_FEATURES := exceptions&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;LOCAL_C_INCLUDES&lt;/strong&gt;&lt;br /&gt;
一个可选的path列表。相对于NDK ROOT 目录。编译时，将会把这些目录附上。&lt;br /&gt;
LOCAL_C_INCLUDES := sources/foo  LOCAL_C_INCLUDES := $(LOCAL_PATH)/../foo&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;LOCAL_CFLAGS&lt;/strong&gt;&lt;br /&gt;
一个可选的设置，在编译C/C++ source 时添加如Flags。
用来附加编译选项。 注意：不要尝试在此处修改编译的优化选项和Debug等级。它会通过您Application.mk中的信息自动指定。&lt;br /&gt;
也可以指定include 目录通过：LOCAL_CFLAGS += -I&lt;path&gt;。 这个方法比使用LOCAL_C_INCLUDES要好。因为这样也可以被ndk-debug使用。&lt;/path&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;LOCAL_CXXFLAGS&lt;/strong&gt;&lt;br /&gt;
LOCAL_CPPFLAGS的别名。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;LOCAL_CPPFLAGS&lt;/strong&gt;&lt;br /&gt;
C++ Source 编译时添加的C Flags。这些Flags将出现在LOCAL_CFLAGS flags 的后面。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;LOCAL_STATIC_LIBRARIES&lt;/strong&gt;&lt;br /&gt;
要链接到本模块的静态库list。(built with BUILD_STATIC_LIBRARY)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;LOCAL_SHARED_LIBRARIES&lt;/strong&gt;&lt;br /&gt;
要链接到本模块的动态库。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;LOCAL_WHOLE_STATIC_LIBRARIES&lt;/strong&gt;&lt;br /&gt;
静态库全链接。 不同于LOCAL_STATIC_LIBRARIES，类似于使用–whole-archive&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;LOCAL_LDLIBS&lt;/strong&gt;&lt;br /&gt;
linker flags。 可以用它来添加系统库。 如 -lz: &lt;br /&gt;
LOCAL_LDLIBS := -lz&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;LOCAL_ALLOW_UNDEFINED_SYMBOLS&lt;/strong&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;LOCAL_ARM_MODE&lt;/strong&gt;&lt;br /&gt;
缺省模式下，ARM目标代码被编译为thumb模式。每个指令16位。如果指定此变量为：arm。 则指令为32位。&lt;br /&gt;
LOCAL_ARM_MODE := arm   其实也可以指定某一个或者某几个文件的ARM指令模式。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;LOCAL_ARM_NEON&lt;/strong&gt;&lt;br /&gt;
设置为true时，会讲浮点编译成neon指令。这会极大地加快浮点运算(前提是硬件支持)
只有targeting 为 ‘armeabi-v7a’时才可以。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;LOCAL_DISABLE_NO_EXECUTE&lt;/strong&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;LOCAL_EXPORT_CFLAGS&lt;/strong&gt;&lt;br /&gt;
定义这个变量用来记录C/C++编译器标志集合，
并且会被添加到其他任何以LOCAL_STATIC_LIBRARIES和LOCAL_SHARED_LIBRARIES的模块的LOCAL_CFLAGS定义中       &lt;br /&gt;
LOCAL_SRC_FILES := foo.c bar.c.arm&lt;/p&gt;

&lt;h2 id=&quot;applicationmk变量&quot;&gt;&lt;strong&gt;Application.mk变量&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;用于描述app需要的native model。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;APP_PROJECT_PATH&lt;/strong&gt;&lt;br /&gt;
这个变量存储应用程序的项目根目录的绝对路径。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;APP_OPTIM&lt;/strong&gt;&lt;br /&gt;
配置release和debug&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;APP_CFLAGS&lt;/strong&gt;&lt;br /&gt;
这个变量存储一组构建系统的C编译器标志传递给编译器编译任何C或c++源代码的任何模块，可以修改应用需要的构建模块而不用修改Android.mk文件&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;APP_CPPFLAGS&lt;/strong&gt;&lt;br /&gt;
和 APP_CFLAGS类似&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;APP_LDFLAGS&lt;/strong&gt;&lt;br /&gt;
 A set of linker flags that the build system passes when linking the application，只对 shared libraries 和 executables有效&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;APP_BUILD_SCRIPT&lt;/strong&gt;&lt;br /&gt;
指定Android.mk文件&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;APP_ABI&lt;/strong&gt;&lt;br /&gt;
指定abi&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;APP_PLATFORM&lt;/strong&gt;&lt;br /&gt;
指定android api版本&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;APP_STL&lt;/strong&gt;&lt;br /&gt;
链接其他的c＋＋支持&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;NDK_TOOLCHAIN_VERSION&lt;/strong&gt;&lt;br /&gt;
gcc编译版本&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;APP_PIE&lt;/strong&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;APP_THIN_ARCHIVE&lt;/strong&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;常用构建系统变量&quot;&gt;&lt;strong&gt;常用构建系统变量&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;构建共享库&lt;/strong&gt;&lt;br /&gt;
为了建立可供主应用程序使用的模块，必须将该模块变成共享库。Android NDK构建系统将BUILD_STATIC_LIBRARY变量设置成build-shared-library.mk文件的保存位置。&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;include $(BUILD_STATIC_LIBRARY)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;构建多个共享库&lt;/strong&gt;&lt;br /&gt;
基于不同应用程序的体系结构，一个单独的Android.mk文件可能产生多个共享库模块，为了达到这个目的，需要在Android.mk文档中定义多个模块。例如：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;LOCAL_PATH := $(call my-dir)&lt;br /&gt;
&lt;br /&gt;
#模块1&lt;br /&gt;
&lt;br /&gt;
include $(CLEAR_VARS)&lt;br /&gt;
LOCAL_MODULE    := hello-jni1&lt;br /&gt;
LOCAL_SRC_FILES := hello-jni1.c&lt;br /&gt;
&lt;br /&gt;
include $(BUILD_SHARED_LIBRARY)&lt;br /&gt;
&lt;br /&gt;
#模块2&lt;br /&gt;
&lt;br /&gt;
include $(CLEAR_VARS)&lt;br /&gt;
LOCAL_MODULE    := hello-jni2&lt;br /&gt;
LOCAL_SRC_FILES := hello-jni2.c&lt;br /&gt;
&lt;br /&gt;
include $(BUILD_SHARED_LIBRARY)&lt;br /&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;在处理完这个Android.mk构建文档之后，Android NDK构建系统会产生libhello-jni1.so和libhello-jni2.so两个共享库。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;构建静态库&lt;/strong&gt;&lt;br /&gt;
Android NDK构建系统也支持静态库，静态库可以用来构建共享库，例如，在将第三方代码添加到现有原生项目中，不用直接将第三方源代码包括在原生项目中，而是将第三方代码编译成静态库，然后并入共享库。&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;LOCAL_PATH := $(call my-dir)     &lt;br /&gt;
    &lt;br /&gt;
#第三方AVI库     &lt;br /&gt;
include $(CLEAR_VARS)     &lt;br /&gt;
    &lt;br /&gt;
LOCAL_MODULE    := avilib     &lt;br /&gt;
LOCAL_SRC_FILES := avilib.c     &lt;br /&gt;
    &lt;br /&gt;
include $(BUILD_SHARED_LIBRARY)     &lt;br /&gt;
    &lt;br /&gt;
#原生模块     &lt;br /&gt;
include $(CLEAR_VARS)     &lt;br /&gt;
    &lt;br /&gt;
LOCAL_MODULE    := hello-jni     &lt;br /&gt;
LOCAL_SRC_FILES := hello-jni.c     &lt;br /&gt;
    &lt;br /&gt;
LOCAL_SHARED_LIBRARIES：=avilib     &lt;br /&gt;
    &lt;br /&gt;
include $(BUILD_SHARED_LIBRARY)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;将第三方代码模块生成静态库后，共享库就可以通过将它的模块名称添加到LOCAL_SHARED_LIBRARIES变量中来使用该模块。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;用公共库共享通用模块&lt;/strong&gt;&lt;br /&gt;
静态库可以保证源代码模块化，但是，当静态库与共享库相连接时，就变成了共享库的一部分。在多个共享库的情况下，多个共享库与同一个静态库连接时，需要将通用模块的多个副本与不同共享库重复连接，这样就增加了应用程序的大小，在这种情况下，我们不用构建静态库，而是将通用模块作为共享库建立起来，而动态连接依赖模块以便消除重复的副本。&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;LOCAL_PATH := $(call my-dir)     &lt;br /&gt;
    &lt;br /&gt;
#第三方AVI库     &lt;br /&gt;
include $(CLEAR_VARS)     &lt;br /&gt;
    &lt;br /&gt;
LOCAL_MODULE    := avilib     &lt;br /&gt;
LOCAL_SRC_FILES := avilib.c     &lt;br /&gt;
include $(BUILD_SHARED_LIBRARY)     &lt;br /&gt;
    &lt;br /&gt;
#原生模块1     &lt;br /&gt;
    &lt;br /&gt;
include $(CLEAR_VARS)     &lt;br /&gt;
LOCAL_MODULE    := hello-jni1     &lt;br /&gt;
LOCAL_SRC_FILES := hello-jni1.c     &lt;br /&gt;
LOCAL_SHARED_LIBRARIES：=avilib     &lt;br /&gt;
    &lt;br /&gt;
include $(BUILD_SHARED_LIBRARY)     &lt;br /&gt;
     &lt;br /&gt;
#原生模块2     &lt;br /&gt;
    &lt;br /&gt;
include $(CLEAR_VARS)     &lt;br /&gt;
LOCAL_MODULE    := hello-jni2     &lt;br /&gt;
LOCAL_SRC_FILES := hello-jni2.c     &lt;br /&gt;
LOCAL_SHARED_LIBRARIES：=avilib     &lt;br /&gt;
    &lt;br /&gt;
include $(BUILD_SHARED_LIBRARY)     &lt;br /&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;在多个NDK项目间共享模块&lt;/strong&gt;&lt;br /&gt;
同时使用静态库和共享库时，可以在模块间共享通用模块。但是要注意的是，所有这些模块必须属于同一个NDK项目。&lt;br /&gt;
1.首先将avilib源代码移动到当前NDK项目以外的位置，如：D:\shared-moudles\transcode\avilib&lt;br /&gt;
2.作为共享模块，avilib需要自己的Android.mk文件，具体配置如下：&amp;lt;br&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;LOCAL_PATH := $(call my-dir)    &lt;br /&gt;
   &lt;br /&gt;
#第三方AVI库    &lt;br /&gt;
include $(CLEAR_VARS)    &lt;br /&gt;
   &lt;br /&gt;
LOCAL_MODULE    := avilib    &lt;br /&gt;
LOCAL_SRC_FILES := avilib.c    &lt;br /&gt;
include $(BUILD_SHARED_LIBRARY)    &lt;br /&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;3.现在可以将avilib模块从当前NDK项目的Android.mk文件中移除。通常，为了避免冲突，我们将以transcode/avilib为参数调用函数宏import-module不分添加在构建文档的末尾。&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;#原生模块    &lt;br /&gt;
include $(CLEAR_VARS)    &lt;br /&gt;
   &lt;br /&gt;
LOCAL_MODULE    := hello-jni1    &lt;br /&gt;
LOCAL_SRC_FILES := hello-jni1.c    &lt;br /&gt;
LOCAL_SHARED_LIBRARIES：=avilib    &lt;br /&gt;
   &lt;br /&gt;
include $(BUILD_SHARED_LIBRARY)    &lt;br /&gt;
   &lt;br /&gt;
$(call import-module,transcode/avilib)    &lt;br /&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;4.import-module函数宏需要先定位共享模块，然后将它导入到NDK项目中。默认情况下，import-module函数宏只搜索/sources目录。为了搜索D:\shared-moudles目录，定义一个名为NDK_MODULE_PATH的新环境变量并将它设置成共享模块的根目录，例如D:\shared-moudles。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;用Prebuilt库&lt;/strong&gt;&lt;br /&gt;
prebulit库有两大作用：
1.想在不发布源代码的情况下将你的模块发布给他人
2.想使用共享模块的预建版来加速构建过程&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;LOCAL_PATH := $(call my-dir)&lt;br /&gt;
&lt;br /&gt;
#第三方AVI库&lt;br /&gt;
include $(CLEAR_VARS)&lt;br /&gt;
&lt;br /&gt;
LOCAL_MODULE    := avilib&lt;br /&gt;
LOCAL_SRC_FILES := libavilib.so&lt;br /&gt;
include $(PREBUILT_SHARED_LIBRARY)&lt;br /&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;其中，LOCAL_SRC_FILES 变量指向的不是源文件，而是实际Prebuild库相对于LOCAL_PATH的位置。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;构建独立的可执行文件&lt;/strong&gt;&lt;br /&gt;
有时候为了方便快速测试和原型设计，我们可能会需要Android NDK构建独立的可执行文件，它们不用打包成APK文件既可以赋值到android设备上的常规Linux应用程序，而且它们可以直接执行，而不通过java应用程序加载。生成独立的可以执行文件需要再Android.mk构建文档中导入BUILD_EXECUTABLE变量。&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;#独立可执行的原生模块
include $(CLEAR_VARS)&lt;br /&gt;
&lt;br /&gt;
LOCAL_MODULE    := moudles&lt;br /&gt;
LOCAL_SRC_FILES := moudles.c&lt;br /&gt;
LOCAL_SHARED_LIBRARIES：=avilib&lt;br /&gt;
&lt;br /&gt;
include $(BUILD_EXECUTABLE)&lt;br /&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;独立的可执行文件以与模块相同的名称放在libs/目录下。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;定义新变量&lt;/strong&gt;&lt;br /&gt;
开发人员可以定义其他新变量来简化他们的构建文件。以LOCAL_和NDK_前缀开头的名称预留给Android NDK构建系统使用，建议大家使用MY_开头。例如：
MY_SRC_FILIES:=avilib.c&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;条件操作&lt;/strong&gt;&lt;br /&gt;
Android.mk构建文件可以包含某些关于这些变量的条件操作，例如，在某个体系结构中包含一个不同的源文件集：&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;……&lt;br /&gt;
ifeq($(TARGET_ARCH),arm)&lt;br /&gt;&lt;br /&gt;
LOCAL_SRC_FILES += armonly.c&lt;br /&gt;
else&lt;br /&gt;
LOCAL_SRC_FILES += generic.c&lt;br /&gt;
endif&lt;br /&gt;
……&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;a href=&quot;http://blog.csdn.net/zhangcanyan/article/details/51932758&quot; style=&quot;text-decoration: none;&quot; target=&quot;_blank&quot; title=&quot;参考网址&quot;&gt;参考网址1&lt;/a&gt;&lt;br /&gt;
 &lt;a href=&quot;http://blog.csdn.net/mynameishuangshuai/article/details/52577228&quot; style=&quot;text-decoration: none;&quot; target=&quot;_blank&quot; title=&quot;参考网址&quot;&gt;参考网址2&lt;/a&gt;&lt;br /&gt;
 &lt;a href=&quot;http://blog.csdn.net/qq_21430549/article/details/53365915&quot; style=&quot;text-decoration: none;&quot; target=&quot;_blank&quot; title=&quot;参考网址&quot;&gt;参考网址3&lt;/a&gt;&lt;br /&gt;&lt;/p&gt;</content><author><name>Leach Chen</name></author><category term="Android" /><category term="JNI" /><summary type="html">看一个简单的Android.mk的例子： LOCAL_PATH := $(call my-dir) include $(CLEAR_VARS) LOCAL_MODULE := hello-jni LOCAL_SRC_FILES := hello-jni.c include $(BUILD_SHARED_LIBRARY)</summary></entry><entry><title type="html">Android JNI—项目配置及用法</title><link href="http://localhost:4000/android-jni-config/" rel="alternate" type="text/html" title="Android JNI—项目配置及用法" /><published>2018-03-07T17:18:00+08:00</published><updated>2018-03-07T17:18:00+08:00</updated><id>http://localhost:4000/android-jni-config</id><content type="html" xml:base="http://localhost:4000/android-jni-config/">&lt;p&gt;主要记录下Android Studio下JNI项目搭建&lt;strong&gt;配置方法、C++支持方式、函数静态动态注册,打印LOG到控制台&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;Google官方JNI Demo &lt;a href=&quot;https://github.com/googlesamples/android-ndk/tree/master/other-builds/ndkbuild&quot; style=&quot;text-decoration: none;&quot; target=&quot;\_blank&quot; title=&quot;点击前往&quot;&gt;Android.mk方式&lt;/a&gt;,JNI Demo &lt;a href=&quot;https://github.com/googlesamples/android-ndk&quot; style=&quot;text-decoration: none;&quot; target=&quot;\_blank&quot; title=&quot;点击前往&quot;&gt;CMakeLists.txt方式&lt;/a&gt;,目前NDK支持Android.mk,CMakeLists.txt编译方式，CMakeLists.txt是谷歌后面推出的编译方式，也是谷歌目前推荐的编译方式。我们先以Android.mk方式讲解学习，后面再介绍CMakeLists.txt方式。&lt;/p&gt;

&lt;h2 id=&quot;项目支持jni配置&quot;&gt;项目支持JNI配置&lt;/h2&gt;

&lt;p&gt;首先我们新建一个Android 项目，命名为TestJni,默认我们创建的项目不支持JNI，我们需要进一步配置：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;在项目src/main目录下新建jni文件夹;&lt;br /&gt;&lt;/li&gt;
  &lt;li&gt;在jni目录下新建一个testjni.c的文件，再新建一个Android.mk的文件，mk文件里输入如下内容：&lt;br /&gt;
    &lt;blockquote&gt;
      &lt;p&gt;LOCAL_PATH := $(call my-dir)&lt;br /&gt;
include $(CLEAR_VARS)&lt;br /&gt;
LOCAL_MODULE:= testjni&lt;br /&gt;
LOCAL_LDLIBS += -llog -lz -landroid&lt;br /&gt;
LOCAL_SRC_FILES := testjni.c&lt;br /&gt;
include $(BUILD_SHARED_LIBRARY)&lt;br /&gt;&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;在项目目录下的build.gradle，android模块里面加入：
    &lt;blockquote&gt;
      &lt;p&gt;externalNativeBuild {&lt;br /&gt;
    ndkBuild {&lt;br /&gt;
      path “src/main/jni/Android.mk”&lt;br /&gt;
    }&lt;br /&gt;
}&lt;br /&gt;
&lt;img src=&quot;/assets/img/blog/androidoriginal/jni/jniconfig/build_config.jpg&quot; alt=&quot;&quot; /&gt;&lt;br /&gt;
这样项目便支持JNI了，如果编写jni代码时，没有代码提示，尝试选择build-&amp;gt;Refresh Linked C++ Projects&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;创建对应的native方法，可以用命令行方式去创建也可以直接鼠标放在native方法上按下alt+enter(eclipse快捷键方式)
    &lt;blockquote&gt;
      &lt;p&gt;&lt;img src=&quot;/assets/img/blog/androidoriginal/jni/jniconfig/method_create.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;项目配置支持c&quot;&gt;项目配置支持C++&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;默认JNI支持的是C方式，JNI里面C方式代码如下：
    &lt;blockquote&gt;
      &lt;p&gt;&lt;img src=&quot;/assets/img/blog/androidoriginal/jni/jniconfig/c_part.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;C里面有很多C++没有的函数，我们如果想JNI支持C++，那我们新建一个testjni.cpp的文件，新建一个Application.mk文件，在里面添加：&lt;br /&gt;
    &lt;blockquote&gt;
      &lt;p&gt;&lt;strong&gt;APP_STL := gnustl_static&lt;br /&gt;&lt;/strong&gt;
&lt;strong&gt;APP_CPPFLAGS := -frtti -fexceptions&lt;/strong&gt;&lt;br /&gt;&lt;br /&gt;
重新Clean Project-&amp;gt;Rebuild Project,C++方式写法如下：
&lt;img src=&quot;/assets/img/blog/androidoriginal/jni/jniconfig/c_part1.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;函数静态动态注册&quot;&gt;函数静态动态注册&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;静态注册方式&lt;/strong&gt;(函数名为JAVA_包名_类名_方法名组成):&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;JNIEXPORT jstring JNICALL Java_com_leachchen_testjni_MainActivity_testMethod(JNIEnv *env, jobject instance, jstring name_) {
	const char *name = (*env)-&amp;gt;GetStringUTFChars(env, name_, 0);
	char buff[128] = {0};
	sprintf(buff,&quot;I am from C part String and get java part String:%s&quot;,name);
	(*env)-&amp;gt;ReleaseStringUTFChars(env, name_, name);

	return (*env)-&amp;gt;NewStringUTF(env, buff);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;动态注册方式&lt;/strong&gt;(指定包名路径，然后可以自定义函数名称与native名称映射):&lt;/p&gt;

&lt;p&gt;1: 指定java里面的native方法所在类的路径#define CLASS_PATH_NAME	 “com/leachchen/testjni/MainActivity”;&lt;br /&gt;
2: 重写JNI_OnLoad方法:&lt;br /&gt;
3: 在JNINativeMethod里面将java里面的native方法及jni里面的方法映射;&lt;br /&gt;
4: 实现java要调用的方法jstring testJniMethod(JNIEnv *env, jobject instance, jstring name_)；&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//testjni.cpp
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;jni.h&amp;gt;
#include &amp;lt;iostream&amp;gt;
using namespace std;

#define CLASS_PATH_NAME	 &quot;com/leachchen/testjni/MainActivity&quot;

/**
 * 静态注册方式
 */
/*extern &quot;C&quot; JNIEXPORT jstring JNICALL
Java_com_leachchen_testjni_MainActivity_testMethod(JNIEnv *env, jobject instance, jstring name_) {
	const char *name = env-&amp;gt;GetStringUTFChars(name_, 0);
	char buff[128] = {0};
	sprintf(buff,&quot;I am from C part String and get java part String:%s&quot;,name);
	env-&amp;gt;ReleaseStringUTFChars(name_, name);

	return env-&amp;gt;NewStringUTF(buff);
}*/

/**
 * 动态注册方式
 */
jstring testJniMethod(JNIEnv *env, jobject instance, jstring name_) {
	const char *name = env-&amp;gt;GetStringUTFChars(name_, 0);
	char buff[128] = {0};
	sprintf(buff,&quot;I am from C part String and get java part String:%s&quot;,name);
	env-&amp;gt;ReleaseStringUTFChars(name_, name);

	return env-&amp;gt;NewStringUTF(buff);
}


//注册Java端的方法以及本地相对应的方法
JNINativeMethod method[]={
	{
		  &quot;testMethod&quot;, //Java中native函数的函数名
		  &quot;(Ljava/lang/String;)Ljava/lang/String;&quot;, // Java中的native对应的native签名
		  (void *)testJniMethod //native 中的方法指针
	 }
};

//注册相应的类以及方法
jint registerNativeMeth(JNIEnv *env){
	jclass cl=env-&amp;gt;FindClass(CLASS_PATH_NAME);
	if((env-&amp;gt;RegisterNatives(cl,method,sizeof(method)/sizeof(method[0])))&amp;lt;0){
		return -1;
	}
	return 0;
}

//实现jni_onload 动态注册方法
jint JNI_OnLoad(JavaVM* vm, void* reserved) {
	JNIEnv* env = NULL;
	if (vm-&amp;gt;GetEnv((void**) &amp;amp;env, JNI_VERSION_1_4) != JNI_OK) {
		return -1;
	}
	if(registerNativeMeth(env)!=JNI_OK){//注册方法
		return -1;
	}
	return JNI_VERSION_1_4;//必须返回这个值
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;打印log到控制台&quot;&gt;打印LOG到控制台&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;首先在Android要加上LOCAL_LDLIBS += -llog -lz -landroid，log支持库
    &lt;blockquote&gt;
      &lt;p&gt;&lt;img src=&quot;/assets/img/blog/androidoriginal/jni/jniconfig/log_config.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;定义如下宏定义，可定义在c,cpp或者.h头文件里
    &lt;blockquote&gt;
      &lt;p&gt;#include &amp;lt;android/log.h&amp;gt;&lt;br /&gt;
#define TAG “MYFFMPEG” // 这个是自定义的LOG的标识&lt;br /&gt;
#define LOGD(…) &lt;strong&gt;android_log_print(ANDROID_LOG_DEBUG,TAG ,__VA_ARGS&lt;/strong&gt;) // 定义LOGD类型&lt;br /&gt;
#define LOGI(…) &lt;strong&gt;android_log_print(ANDROID_LOG_INFO,TAG ,__VA_ARGS&lt;/strong&gt;) // 定义LOGI类型&lt;br /&gt;
#define LOGW(…) &lt;strong&gt;android_log_print(ANDROID_LOG_WARN,TAG ,__VA_ARGS&lt;/strong&gt;) // 定义LOGW类型&lt;br /&gt;
#define LOGE(…) &lt;strong&gt;android_log_print(ANDROID_LOG_ERROR,TAG ,__VA_ARGS&lt;/strong&gt;) // 定义LOGE类型&lt;br /&gt;
#define LOGF(…) &lt;strong&gt;android_log_print(ANDROID_LOG_FATAL,TAG ,__VA_ARGS&lt;/strong&gt;) // 定义LOGF类型&lt;br /&gt;&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;调用方式: LOGE(“get java value:%s”,value);&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;源码参考samples里面的TestJni&lt;/p&gt;
&lt;h1&gt;&lt;a href=&quot;https://github.com/leach-chen/TestProject/tree/master/samples/TestJni&quot; style=&quot;text-decoration: none;&quot; target=&quot;_blank&quot; title=&quot;源码下载&quot;&gt;源码下载&lt;/a&gt;
&lt;h1&gt;
&lt;/h1&gt;&lt;/h1&gt;</content><author><name>Leach Chen</name></author><category term="Android" /><category term="JNI" /><summary type="html">主要记录下Android Studio下JNI项目搭建配置方法、C++支持方式、函数静态动态注册,打印LOG到控制台。</summary></entry><entry><title type="html">Android GPS解析</title><link href="http://localhost:4000/android-gps/" rel="alternate" type="text/html" title="Android GPS解析" /><published>2018-03-07T14:09:00+08:00</published><updated>2018-03-07T14:09:00+08:00</updated><id>http://localhost:4000/android-gps</id><content type="html" xml:base="http://localhost:4000/android-gps/">&lt;p&gt;在做轨迹相关功能时经常需要GPS解析，从GPS文件中我们可以提取出经纬度信息，速度，方向，时间等信息。&lt;br /&gt;
GPS格式可阅读&lt;a href=&quot;https://leach-chen.github.io/GPS-file/&quot; title=&quot;点击前往&quot;&gt;这篇博客&lt;/a&gt;。
把GPS文件中的经纬度信息提取出来，我们就可以在地图上绘制轨迹信息了。这里有个GPS格式文件的&lt;a href=&quot;https://github.com/eantoranz/gps-parser&quot; title=&quot;点击前往&quot;&gt;解析库&lt;/a&gt;，可解析出&lt;strong&gt;经纬度，速度，方向，时间&lt;/strong&gt;等信息，具体用法可以在看文章底部提供的源码。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/blog/androidoriginal/gps/gpsparase.gif&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;世界坐标转系火星坐标系&lt;/strong&gt;&lt;br /&gt;
往往设备记录下来的坐标是原始坐标系，这是国际公认的世界标准坐标体系，我们地图上要绘制的时候一般要先转换为火星坐标系，通过下面代码中&lt;strong&gt;transform(double wgLat, double wgLon)&lt;/strong&gt;，传入经纬度，便可得到转换后的经纬度信息了。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class EvilTransform {
    final static double pi = 3.14159265358979324;

    //
    //
    // a = 6378245.0, 1/f = 298.3
    // b = a * (1 - f)
    // ee = (a^2 - b^2) / a^2;
    final static double a = 6378245.0;
    final static double ee = 0.00669342162296594323;


    final static double DEF_PI = 3.14159265359; // PI
    final static double DEF_2PI = 6.28318530712; // 2*PI
    final static double DEF_PI180 = 0.01745329252; // PI/180.0
    final static double DEF_R = 6370693.5; // radius of earth


    //
    // World Geodetic System ==&amp;gt; Mars Geodetic System
    public static double[] transform(double wgLat, double wgLon) {
        double mgLat = 0;
        double mgLon = 0;
        if (outOfChina(wgLat, wgLon)) {
            mgLat = wgLat;
            mgLon = wgLon;

        } else {
            double dLat = transformLat(wgLon - 105.0, wgLat - 35.0);
            double dLon = transformLon(wgLon - 105.0, wgLat - 35.0);
            double radLat = wgLat / 180.0 * pi;
            double magic = Math.sin(radLat);
            magic = 1 - ee * magic * magic;
            double sqrtMagic = Math.sqrt(magic);
            dLat = (dLat * 180.0) / ((a * (1 - ee)) / (magic * sqrtMagic) * pi);
            dLon = (dLon * 180.0) / (a / sqrtMagic * Math.cos(radLat) * pi);
            mgLat = wgLat + dLat;
            mgLon = wgLon + dLon;
        }
        double[] point = {mgLat, mgLon};
        return point;
    }

    private static boolean outOfChina(double lat, double lon) {
        if (lon &amp;lt; 72.004 || lon &amp;gt; 137.8347)
            return true;
        if (lat &amp;lt; 0.8293 || lat &amp;gt; 55.8271)
            return true;
        return false;
    }

    private static double transformLat(double x, double y) {
        double ret = -100.0 + 2.0 * x + 3.0 * y + 0.2 * y * y + 0.1 * x * y + 0.2 * Math.sqrt(Math.abs(x));
        ret += (20.0 * Math.sin(6.0 * x * pi) + 20.0 * Math.sin(2.0 * x * pi)) * 2.0 / 3.0;
        ret += (20.0 * Math.sin(y * pi) + 40.0 * Math.sin(y / 3.0 * pi)) * 2.0 / 3.0;
        ret += (160.0 * Math.sin(y / 12.0 * pi) + 320 * Math.sin(y * pi / 30.0)) * 2.0 / 3.0;
        return ret;
    }

    private static double transformLon(double x, double y) {
        double ret = 300.0 + x + 2.0 * y + 0.1 * x * x + 0.1 * x * y + 0.1 * Math.sqrt(Math.abs(x));
        ret += (20.0 * Math.sin(6.0 * x * pi) + 20.0 * Math.sin(2.0 * x * pi)) * 2.0 / 3.0;
        ret += (20.0 * Math.sin(x * pi) + 40.0 * Math.sin(x / 3.0 * pi)) * 2.0 / 3.0;
        ret += (150.0 * Math.sin(x / 12.0 * pi) + 300.0 * Math.sin(x / 30.0 * pi)) * 2.0 / 3.0;
        return ret;
    }

    public static double GetShortDistance(double lon1, double lat1, double lon2,double lat2) {
        double ew1, ns1, ew2, ns2;
        double dx, dy, dew;
        double distance;
        // 角度转换为弧度
        ew1 = lon1 * DEF_PI180;
        ns1 = lat1 * DEF_PI180;
        ew2 = lon2 * DEF_PI180;
        ns2 = lat2 * DEF_PI180;
        // 经度差
        dew = ew1 - ew2;
        // 若跨东经和西经180 度，进行调整
        if (dew &amp;gt; DEF_PI)
            dew = DEF_2PI - dew;
        else if (dew &amp;lt; -DEF_PI)
            dew = DEF_2PI + dew;
        dx = DEF_R * Math.cos(ns1) * dew; // 东西方向长度(在纬度圈上的投影长度)
        dy = DEF_R * (ns1 - ns2); // 南北方向长度(在经度圈上的投影长度)
        // 勾股定理求斜边长
        distance = Math.sqrt(dx * dx + dy * dy);
        return distance;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;获取轨迹距离&lt;/strong&gt;&lt;br /&gt;
获取一段轨迹的距离，我们可以依次计算相邻两个轨迹点之间的距离，再累加起来，便可以得到这段轨迹的距离了，通过上面代码中&lt;strong&gt;GetShortDistance(double lon1, double lat1, double lon2,double lat2)&lt;/strong&gt;函数，前两个参数是前一个点的经纬度，后两个参数是后一个点的经纬度。&lt;/p&gt;

&lt;p&gt;源码参考samples里面的TestGps&lt;/p&gt;
&lt;h1&gt;&lt;a href=&quot;https://github.com/leach-chen/TestProject/tree/master/samples/TestGps&quot; style=&quot;text-decoration: none;&quot; target=&quot;_blank&quot; title=&quot;源码下载&quot;&gt;源码下载&lt;/a&gt;
&lt;h1&gt;
&lt;/h1&gt;&lt;/h1&gt;</content><author><name>Leach Chen</name></author><category term="Android" /><category term="GPS" /><summary type="html">在做轨迹相关功能时经常需要GPS解析，从GPS文件中我们可以提取出经纬度信息，速度，方向，时间等信息。 GPS格式可阅读这篇博客。 把GPS文件中的经纬度信息提取出来，我们就可以在地图上绘制轨迹信息了。这里有个GPS格式文件的解析库，可解析出经纬度，速度，方向，时间等信息，具体用法可以在看文章底部提供的源码。</summary></entry></feed>